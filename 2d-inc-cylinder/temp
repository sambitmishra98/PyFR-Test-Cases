import math
from sigfig import round

import numpy as np

from pyfr.integrators.dual.phys.base import BaseDualIntegrator
from pyfr.mpiutil import get_comm_rank_root, mpi

class BaseDualController(BaseDualIntegrator):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.n = len(str(self._dt).split(".")[1])
        # Solution filtering frequency
        self._fnsteps = self.cfg.getint('soln-filter', 'nsteps', '0')

        # Fire off any event handlers if not restarting
        if not self.isrestart:
            for csh in self.completed_step_handlers:
                csh(self)

    def _accept_step(self, dt, idxcurr):
        self.tcurr += dt
        self.nacptsteps += 1
        self.nacptchain += 1

        # Filter
        if self._fnsteps and self.nacptsteps % self._fnsteps == 0:
            self.pseudointegrator.system.filt(idxcurr)

        # Invalidate the solution cache
        self._curr_soln = None

        # Invalidate the solution gradients cache
        self._curr_grad_soln = None

        # Fire off any event handlers
        for csh in self.completed_step_handlers:
            csh(self)

        # Abort if plugins request it
        self._check_abort()

        # Clear the pseudo step info
        self.pseudointegrator.pseudostepinfo = []


class DualNoneController(BaseDualController):
    controller_name = 'none'

    def advance_to(self, t):

        # Ensure that the step can be taken without machine-errors
        t = round(t, decimals=self.n)

        if t < self.tcurr:
            raise ValueError('Advance time is in the past')

        while abs(self.tcurr-t)>self.dtmin:
            self.tcurr = round(self.tcurr, decimals=self.n)

            # Take a variable implicit time-step
            dt2 = max(min(t - self.tcurr, self._dt), self.dtmin)
            dt = round(dt2, decimals=self.n)

            if self.pseudointegrator.dt != dt:
                self.pseudointegrator.dt = dt
                
            # Take the physical step
            self.step(self.tcurr, dt)

            # We are not adaptive, so accept every step
            self._accept_step(dt, self.pseudointegrator._idxcurr)


class DualPIController(BaseDualController):
    controller_name = 'pi'


    def _errest(self, rcurr, rprev, rerr):
        comm, rank, root = get_comm_rank_root()

        self._norm = 'l2'
        self._atol = 1e-08
        self._rtol = 1e-08

        # Get a set of kernels to estimate the integration error
        ekerns = self.pseudointegrator.pintgs[3]._get_reduction_kerns(rcurr, rprev, rerr, method='errest',
                                           norm=self._norm)

        # Bind the dynamic arguments
        for kern in ekerns:
            kern.bind(self._atol, self._rtol)

        # Run the kernels
        self.backend.run_kernels(ekerns, wait=True)

        # Pseudo L2 norm
        if self._norm == 'l2':
            # Reduce locally (element types + field variables)
            err = np.array([sum(v for k in ekerns for v in k.retval)])

            # Reduce globally (MPI ranks)
            comm.Allreduce(mpi.IN_PLACE, err, op=mpi.SUM)

            # Normalise
            err = math.sqrt(float(err) / self.pseudointegrator.pintgs[3]._gndofs)
        # Uniform norm
        else:
            # Reduce locally (element types + field variables)
            err = np.array([max(v for k in ekerns for v in k.retval)])

            # Reduce globally (MPI ranks)
            comm.Allreduce(mpi.IN_PLACE, err, op=mpi.MAX)

            # Normalise
            err = math.sqrt(float(err))

        return err if not math.isnan(err) else 100

    def advance_to(self, t):

        # Ensure that the step can be taken without machine-errors
        t = round(t, decimals=self.n)

        if t < self.tcurr:
            raise ValueError('Advance time is in the past')

        while abs(self.tcurr-t)>self.dtmin:
            self.tcurr = round(self.tcurr, decimals=self.n)

            # Decide on the time-step
            dt2 = max(min(t - self.tcurr, self._dt), self.dtmin)
            dt = round(dt2, decimals=self.n)

            # Prepare all multi-p levels before taking the step
            if self.pseudointegrator.dt != dt:
                print(f"dt = {self.pseudointegrator.dt} --> {dt}... {self.tcurr = } {t = }")
                self.pseudointegrator.dt = dt
                
            # Take the physical step
            idxcurr, idxprev, idxerr = self.step(self.tcurr, dt)

            # Estimate the error
            #print(f"Estimating error... {idxerr = }")
            err3 = self._errest(idxcurr, idxprev, 3)
            print(f"{err3}")

            # We are not adaptive, so accept every step
            self._accept_step(dt, self.pseudointegrator._idxcurr)
